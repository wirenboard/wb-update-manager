"""
These items are moved from release.py without changes to use it in the Bullseye updater
"""

import errno
import logging
import os
import shutil
import subprocess
import textwrap
import urllib.request
from collections import namedtuple
from pathlib import Path
from urllib.error import HTTPError

__all__ = (
    "CONFIRM_STEPS_ARGNAME",
    "LOG_FILENAME_ARGNAME",
    "NO_PRELIMINARY_UPDATE_ARGNAME",
    "RETCODE_EINVAL",
    "RETCODE_FAULT",
    "RETCODE_NO_TARGET",
    "RETCODE_OK",
    "RETCODE_USER_ABORT",
    "DEFAULT_REPO_URL",
    "UPDATE_DEBIAN_RELEASE_ARGNAME",
    "WB_RELEASE_FILENAME",
    "WB_SOURCES_LIST_FILENAME",
    "WB_ORIGIN",
    "ReleaseInfo",
    "SystemState",
    "UserAbortException",
    "logger",
    "user_confirm",
    "make_full_repo_url",
    "release_exists",
    "run_apt",
    "run_cmd",
    "generate_system_config",
    "_cleanup_apt_cached_lists",
)

RETCODE_OK = 0
RETCODE_USER_ABORT = 1
RETCODE_FAULT = 2
RETCODE_NO_TARGET = 3
RETCODE_EINVAL = errno.EINVAL

DEFAULT_REPO_URL = "http://deb.wirenboard.com/"

WB_ORIGIN = "wirenboard"
WB_RELEASE_FILENAME = "/usr/lib/wb-release"
WB_SOURCES_LIST_FILENAME = "/etc/apt/sources.list.d/wirenboard.list"
WB_RELEASE_APT_PREFERENCES_FILENAME = "/etc/apt/preferences.d/20wb-release"

CONFIRM_STEPS_ARGNAME = "--confirm-steps"
LOG_FILENAME_ARGNAME = "--log-filename"
NO_PRELIMINARY_UPDATE_ARGNAME = "--no-preliminary-update"
UPDATE_DEBIAN_RELEASE_ARGNAME = "--update-debian-release"


class UserAbortException(Exception):
    pass


ReleaseInfo = namedtuple("ReleaseInfo", "release_name suite target repo_prefix")
SystemState = namedtuple("SystemState", "suite target repo_prefix consistent")

logger = logging.getLogger("wb-release")


def user_confirm(text=None, assume_yes=False):
    if text:
        print("\n" + text + "\n")

    if assume_yes:
        return

    while True:
        result = input("Are you sure you want to continue? (y/n): ").lower().strip()
        if not result:
            continue
        if result[0] == "y":
            return
        else:
            raise UserAbortException


def make_full_repo_url(state: SystemState, base_url=DEFAULT_REPO_URL):
    base_url = base_url.strip(" /")
    prefix = ("/" + state.repo_prefix).rstrip(" /")
    return base_url + prefix + "/" + state.target


def release_exists(state: SystemState):
    full_url = make_full_repo_url(state) + "/dists/{}/Release".format(state.suite)
    logger.info("Accessing {}...".format(full_url))

    try:
        resp = urllib.request.urlopen(full_url, timeout=10.0)
        logger.info("Response code {}".format(resp.getcode()))
    except HTTPError as e:
        if e.code >= 400 and e.code < 500:
            logger.info("Response code {}".format(e.code))
            return False
        else:
            raise
    else:
        return True


def run_apt(*cmd, assume_yes=False, immediate_configure=False):
    args = ["apt-get", "-q"] + list(cmd)
    env = os.environ.copy()

    env["DEBIAN_FRONTEND"] = "noninteractive"
    args += [
        "-o",
        "Dpkg::Options::=--force-confdef",
        "-o",
        "Dpkg::Options::=--force-confold",
        "--allow-downgrades",
    ]

    if immediate_configure:
        args += ["-o", "APT::Immediate-Configure=false"]

    if assume_yes:
        args += ["--yes"]

    try:
        run_cmd(*args, env=env, log_suffix="apt.{}".format(cmd[0]))
    except subprocess.CalledProcessError as e:
        if e.returncode == 1:
            raise UserAbortException()
        else:
            raise


def run_cmd(*args, env=None, log_suffix=None):
    if not log_suffix:
        log_suffix = args[0]

    logger.debug('Starting cmd: "{}"'.format(" ".join(list(args))))
    logger.debug('Environment: "{}"'.format(env))

    proc_logger = logger.getChild(log_suffix)

    if env is None:
        env = {}

    env["LANG"] = "C"

    with subprocess.Popen(args, env=env, stdout=subprocess.PIPE, stderr=subprocess.STDOUT) as proc:
        try:
            with proc.stdout:
                for line in iter(proc.stdout.readline, b""):
                    # remove all non-unicode characters from line for not to confuse ASCII terminal
                    proc_logger.info(line.decode("ascii", "ignore").rstrip().rsplit("\r", 1)[-1])

            retcode = proc.wait()
            if retcode != 0:
                raise subprocess.CalledProcessError(retcode, args)
        except KeyboardInterrupt:
            logger.info("Ctrl-C caught, waiting for child process %s to shut down", args[0])
            raise


def generate_sources_list(state: SystemState, base_url=DEFAULT_REPO_URL, filename=WB_SOURCES_LIST_FILENAME):
    suite = state.suite
    full_repo_url = make_full_repo_url(state, base_url)

    with open(filename, "w") as f:
        f.write(
            textwrap.dedent(
                """
                # This file is automatically generated by wb-release.
                # DO NOT EDIT THIS FILE!
                #
                # If you want to switch to testing, use command
                #   wb-release -t testing
                deb {full_repo_url} {suite} main"""
            )
            .format(full_repo_url=full_repo_url, suite=suite)
            .strip()
        )


def generate_release_apt_preferences(
    state: SystemState, origin=WB_ORIGIN, filename=WB_RELEASE_APT_PREFERENCES_FILENAME
):
    with open(filename, "w") as f:
        f.write(
            textwrap.dedent(
                """
                # This file is automatically generated by wb-release.
                # DO NOT EDIT THIS FILE!
                #
                # If you want to switch to testing, use command
                #   wb-release -t testing
                Package: *
                Pin: release o={origin}, a={suite}
                Pin-Priority: 990"""
            )
            .format(origin=origin, suite=state.suite)
            .strip()
        )


def generate_system_config(state):
    logger.info("Generating {} for {}".format(WB_SOURCES_LIST_FILENAME, state))
    generate_sources_list(state, filename=WB_SOURCES_LIST_FILENAME)

    logger.info("Generating {} for {}".format(WB_RELEASE_APT_PREFERENCES_FILENAME, state))
    generate_release_apt_preferences(state, filename=WB_RELEASE_APT_PREFERENCES_FILENAME)


def _cleanup_apt_cached_lists(cache_dir="/var/lib/apt/lists"):
    if os.path.exists(cache_dir):
        for path in Path(cache_dir).resolve().glob("**/*"):
            if path.is_file():
                path.unlink()
            elif path.is_dir():
                shutil.rmtree(str(path))
